#!/usr/bin/ruby

#
# bbb-user-data-forget.rb
#

require 'trollop'
require 'nokogiri'
require 'csv'
require 'fileutils'
require 'terminal-table'

$opts = Trollop.options do
  opt :dryrun, 'runs a dry run'
  opt :Delete, 'deletes user Data'
  opt :userId, 'userId', type: :string
  opt :recordingID, 'recordingID', type: :string
end

$removalList = []
$audioFile
$meetingStart
$start_speaking

def delUserInfo(user_id, dir_id)
  if user_id.nil?
    puts 'You did not specify an id.'
    puts 'Please provide an id as an argument before you run this script'
    exit
  end
  recording_start = 0
  meeting_end = 0
  $start_speaking = 0
  rows = []
  rows << %w[event user_Id module removed start end]

  Dir.glob("#{dir_id}/events.xml") do |file|
    doc = Nokogiri::XML(File.open(File.expand_path(file)))
    events = doc.xpath('//event')
    meeting_start = Integer(events.first.at_xpath('@timestamp').to_s)
    meeting_end = Integer(events.last.at_xpath('@timestamp').to_s)
    directory = File.dirname(File.absolute_path(file))
    events.each do |event|
      dry? && next if %w[PRESENTATION WHITEBOARD].include? event.at_xpath('@module').to_s
      e_name = event.at_xpath('@eventname').to_s
      if e_name.eql? 'StartRecordingEvent'
        recording_start = Integer(event.at_xpath('recordingTimestamp').content.to_s)
        display_event(event, rows, '', 'start Recording at: ', f_time(recording_start - meeting_start))
        next
      end
      unless user?(event, user_id)
        dry? && display_event(event, rows, '')
        next
      end
      if e_name.eql? 'ParticipantJoinEvent'
        e_stamp = event.at_xpath('@timestamp').to_s
        $start_speaking = (Integer(e_stamp) - recording_start)
      end
      remove_event(event, rows, directory, recording_start, meeting_start)
    end
    File.open(File.expand_path(file), 'w') { |f| doc.write_xml_to f }
  end
  puts dry? ? 'Dry run' : 'Data removal run'
  puts "data concerning user with Id: #{user_id}"
  table = Terminal::Table.new title: 'Info', headings: ["id: #{user_id}"], rows: rows
  puts table
  remove_audio(meeting_end - recording_start)
end

def user?(event, user_id)
  e_name = event.at_xpath('@eventname').to_s
  if %w[StopWebcamShareEvent StartWebcamShareEvent].include? e_name
    e_stream = event.at_xpath('stream').content.to_s
    return e_stream.include? user_id
  end
  get_uid(event) == user_id
end

def get_uid(event)
  userid = event.at_xpath('userId')
  userid.nil? && userid = event.at_xpath('userid')
  userid.nil? && userid = event.at_xpath('senderId')
  userid.nil? && userid = event.at_xpath('participant')
  userid.nil? ? 'unkown' : userid.content
end

def true?(obj)
  obj.to_s == 'true'
end

def f_time(time)
  Time.at(time / 1000).utc.strftime('%H:%M:%S')
end

def remove_audio_event(event)
  event.remove
end

def make_audio_removal_request(start, finish)
  { start: start, finish: finish }
end

def dry?
  $opts[:dryrun]
end

def remove_audio(meetingDuration)
  if $audioFile.nil? || $removalList.nil?
    puts 'No audio file present.\n No audio has been removed'
    return
  end
  total_time = 0
  command = ['ffmpeg', '-i', $audioFile, '-af']
  filter = "volume=volume=0:enable='"

  loop do
    filter += 'between(t\\,' + $removalList.first[:start]
    filter += '\\,' + $removalList.first[:finish] + ')'
    total_time += Integer($removalList.first[:finish]) - Integer($removalList.first[:start])
    $removalList.shift
    $removalList.empty? && break
    filter += '+'
  end
  filter += "'"

  command << filter
  command << '-y'
  command << 'temp.wav'
  if dry?
    puts "command that was going to run: \n#{command.join(' ')}"
  else
    system(*command)
    FileUtils.mv 'temp.wav', $audioFile
    puts 'All audio recordings have been removed'
  end
  puts "Recording total time: #{f_time(meetingDuration)} ."
  puts "Total time that was going to be muted: #{f_time(total_time)} ."
end

def removeParticipantMutedEvent(event, rows, directory, recording_start)
  !true?(event.at_xpath('muted').content.to_s) && return
  e_timestamp = (Integer(event.at_xpath('@timestamp').to_s) - recording_start)
  Dir.glob("#{directory}/audio/*.wav") do |audiofile|
    puts "req -r audio: [#{f_time($start_speaking)}, #{f_time(e_timestamp)}]"
    $audioFile = audiofile
    $removalList.push(make_audio_removal_request($start_speaking.to_s, e_timestamp.to_s))
  end
  display_event(event, rows, 'X', 'mic muted:', f_time(e_timestamp))
  $start_speaking = e_timestamp
  !dry? && remove_audio_event(event)
end

def removeParticipantTalkingEvent(event, rows, directory, recording_start)
  e_timestamp = (Integer(event.at_xpath('@timestamp').to_s) - recording_start)
  if true?(event.at_xpath('talking').content)
    $start_speaking = e_timestamp
    display_event(event, rows, 'X', 'mic on:', f_time(e_timestamp))
  else
    Dir.glob("#{directory}/audio/*.wav") do |audiofile|
      puts "req -r audio: [#{f_time($start_speaking)}, #{f_time(e_timestamp)}]"
      $audioFile = audiofile
      $removalList.push(make_audio_removal_request($start_speaking.to_s, e_timestamp.to_s))
    end
    display_event(event, rows, 'X', 'mic off:', f_time(e_timestamp))
    $start_speaking = e_timestamp
  end
  !dry? && remove_audio_event(event)
end

def remove_event(event, rows, directory, r_start, meeting_start)
  !dry? && event.remove
  e_module = event.at_xpath('@module')
  e_name = event.at_xpath('@eventname').to_s
  e_timestamp =  Integer(event.at_xpath('@timestamp').to_s)
  return if ['WHITEBOARD'].include? e_module.to_s
  if e_name.eql? 'ParticipantJoinEvent' 
    return display_event(event, rows, 'X', 'user joined at: ', f_time(e_timestamp - meeting_start))
  end
  e_name.eql?('ParticipantMutedEvent') && removeParticipantMutedEvent(event, rows, directory, r_start)
  e_name.eql?('ParticipantTalkingEvent') && removeParticipantTalkingEvent(event, rows, directory, r_start)
  display_event(event, rows, 'X')
end

def display_event(event, rows, delete, start = '', finish = '')
  e_name = event.at_xpath('@eventname')
  e_module = event.at_xpath('@module')
  rows << [e_name, get_uid(event), e_module, delete, start, finish]
end


if $opts[:userId].nil? || $opts[:recordingID].nil?
  puts 'please provide userId and recording ID like so:'
  puts './bbb-user-data-forget -u <userID> -r <recordingId>'
  return
end


delUserInfo($opts[:userId], $opts[:recordingID])
